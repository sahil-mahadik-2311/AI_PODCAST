# services/podcast/service.py
from datetime import datetime
from typing import Dict, Optional

from app.core.config import settings
from app.core.logger import logger

from .file_utils import save_script
from .audio import generate_audio_from_script, generate_podcast_audio


class PodcastService:
    """
    Service for complete podcast generation workflow.
    Handles TWO separate podcast scripts (English and Hindi) independently.
    
    Workflow:
    1. Receive English + Hindi scripts (already generated by agent)
    2. Save both scripts to files
    3. Generate audio for each script separately
    """
    
    def __init__(self):
        self.tts_url = "https://api.sarvam.ai/text-to-speech"
        self.sarvam_api_key = getattr(settings, 'SARVAM_API_KEY', None)

    async def generate_audio_from_script(self, *args, **kwargs):
        """Delegate to standalone audio generation function"""
        return await generate_audio_from_script(*args, **kwargs)

    async def generate_podcast_audio(self, *args, **kwargs):
        """Delegate to standalone podcast audio generation function"""
        return await generate_podcast_audio(*args, **kwargs)

    async def generate_full_podcast(
        self,
        eng_script: str,
        hin_script: str,
        topic: str = "podcast",
        output_format: str = "mp3",
        eng_speaker: Optional[str] = None,
        hin_speaker: Optional[str] = None,
    ) -> Dict:
        """
        Generate COMPLETE podcast with English and Hindi scripts.
        
        This is the main entry point for podcast generation.
        Expects TWO separate pre-generated scripts (not merged).
        
        Workflow:
        1. Save both scripts to files
        2. Generate audio for English script
        3. Generate audio for Hindi script
        4. Return paths to both scripts and audio files
        
        Args:
            eng_script: English podcast script (already generated by agent)
            hin_script: Hindi podcast script (already generated by agent)
            topic: Podcast topic/name (for file naming)
            output_format: "mp3" or "wav"
            eng_speaker: English speaker name (default: "sachit")
            hin_speaker: Hindi speaker name (default: "anushka")
        
        Returns:
            Dictionary with complete podcast information:
            {
                "success": True,
                "eng_pod": {
                    "script_path": "/scripts/podcast_en_20260226_120000.txt",
                    "script_length": 1500,
                    "audio_path": "/audio/podcast_en_20260226_120000.mp3",
                    "speaker": "sachit"
                },
                "hin_pod": {
                    "script_path": "/scripts/podcast_hi_20260226_120000.txt",
                    "script_length": 1600,
                    "audio_path": "/audio/podcast_hi_20260226_120000.mp3",
                    "speaker": "anushka"
                },
                "format": "mp3",
                "topic": "podcast",
                "timestamp": "2026-02-26T12:00:00"
            }
        """
        logger.info("=" * 70)
        logger.info("STARTING COMPLETE PODCAST GENERATION")
        logger.info("=" * 70)
        logger.info(f"Topic: {topic}")
        logger.info(f"Output format: {output_format}")
        
        try:
            # Validate inputs
            if not eng_script or not hin_script:
                logger.error("Both English and Hindi scripts are required")
                return {
                    "success": False,
                    "error": "Missing English or Hindi script"
                }
            
            # Set default speakers
            eng_speaker = eng_speaker or "sachit"
            hin_speaker = hin_speaker or "anushka"
            
            # ===== SAVE SCRIPTS =====
            logger.info("\n" + "-" * 70)
            logger.info("[1/4] SAVING SCRIPTS")
            logger.info("-" * 70)
            
            # Save English script
            logger.info(f"Saving English script ({len(eng_script)} chars)...")
            eng_script_path = await save_script(eng_script, f"{topic}_english")
            
            if not eng_script_path:
                logger.error("Failed to save English script")
                return {
                    "success": False,
                    "error": "Failed to save English script"
                }
            
            logger.info(f"✓ English script saved: {eng_script_path}")
            
            # Save Hindi script
            logger.info(f"Saving Hindi script ({len(hin_script)} chars)...")
            hin_script_path = await save_script(hin_script, f"{topic}_hindi")
            
            if not hin_script_path:
                logger.error("Failed to save Hindi script")
                return {
                    "success": False,
                    "error": "Failed to save Hindi script"
                }
            
            logger.info(f"✓ Hindi script saved: {hin_script_path}")
            
            # ===== GENERATE AUDIO =====
            logger.info("\n" + "-" * 70)
            logger.info("[2/4] GENERATING PODCAST AUDIO")
            logger.info("-" * 70)
            
            if not self.sarvam_api_key:
                logger.error("Sarvam API key not configured")
                return {
                    "success": False,
                    "error": "Sarvam API key not configured"
                }
            
            # Generate audio for both scripts
            audio_result = await generate_podcast_audio(
                eng_script=eng_script,
                hin_script=hin_script,
                sarvam_api_key=self.sarvam_api_key,
                tts_url=self.tts_url,
                output_format=output_format,
                eng_speaker=eng_speaker,
                hin_speaker=hin_speaker
            )
            
            if not audio_result or not audio_result.get("success"):
                logger.error("Failed to generate audio")
                return {
                    "success": False,
                    "error": "Failed to generate audio files"
                }
            
            # ===== COMPILE RESULTS =====
            logger.info("\n" + "-" * 70)
            logger.info("[3/4] COMPILING RESULTS")
            logger.info("-" * 70)
            
            timestamp = datetime.now().isoformat()
            
            result = {
                "success": True,
                "eng_pod": {
                    "script_path": eng_script_path,
                    "script_length": len(eng_script),
                    "audio_path": audio_result.get("eng_pod_audio"),
                    "speaker": eng_speaker,
                    "language": "en"
                },
                "hin_pod": {
                    "script_path": hin_script_path,
                    "script_length": len(hin_script),
                    "audio_path": audio_result.get("hin_pod_audio"),
                    "speaker": hin_speaker,
                    "language": "hi"
                },
                "format": output_format,
                "topic": topic,
                "timestamp": timestamp,
                "total_script_chars": len(eng_script) + len(hin_script)
            }
            
            logger.info(f"✓ English: {eng_script_path}")
            logger.info(f"✓ English Audio: {audio_result.get('eng_pod_audio')}")
            logger.info(f"✓ Hindi: {hin_script_path}")
            logger.info(f"✓ Hindi Audio: {audio_result.get('hin_pod_audio')}")
            
            logger.info("\n" + "=" * 70)
            logger.info("✓ PODCAST GENERATION COMPLETE")
            logger.info("=" * 70 + "\n")
            
            return result
        
        except Exception as e:
            logger.exception(f"Podcast generation failed: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def generate_podcast_from_agent_result(
        self,
        agent_result: Dict,
        topic: str = "podcast",
        output_format: str = "mp3",
        eng_speaker: Optional[str] = None,
        hin_speaker: Optional[str] = None,
    ) -> Dict:
        """
        Generate complete podcast from agent result dictionary.
        
        This is a convenience method that takes the output from
        UnifiedAgentService and generates scripts + audio.
        
        Args:
            agent_result: Dictionary from unified_agent_service.process_podcast_request()
                         Expected keys: "eng_pod", "hin_pod", "success"
            topic: Podcast topic/name
            output_format: "mp3" or "wav"
            eng_speaker: English speaker name
            hin_speaker: Hindi speaker name
        
        Returns:
            Complete podcast generation result dictionary
        
        Example:
            # Generate scripts with agent
            scripts = await unified_agent_service.process_podcast_request()
            
            # Generate complete podcast (scripts + audio)
            podcast = await podcast_service.generate_podcast_from_agent_result(
                agent_result=scripts,
                topic="daily_financial_update",
                output_format="mp3"
            )
        """
        logger.info("Generating podcast from agent result...")
        
        if not agent_result.get("success"):
            logger.error("Agent result indicates failure")
            return {
                "success": False,
                "error": "Invalid agent result"
            }
        
        eng_script = agent_result.get("eng_pod")
        hin_script = agent_result.get("hin_pod")
        
        if not eng_script or not hin_script:
            logger.error("Agent result missing eng_pod or hin_pod")
            return {
                "success": False,
                "error": "Missing scripts in agent result"
            }
        
        return await self.generate_full_podcast(
            eng_script=eng_script,
            hin_script=hin_script,
            topic=topic,
            output_format=output_format,
            eng_speaker=eng_speaker,
            hin_speaker=hin_speaker
        )

    async def generate_podcast_single_script(
        self,
        script: str,
        language: str = "hi",
        topic: str = "podcast",
        output_format: str = "mp3",
        speaker: Optional[str] = None,
    ) -> Dict:
        """
        Legacy method for single script podcast generation.
        
        Use this only for single-language podcasts.
        For bilingual podcasts, use generate_full_podcast() instead.
        
        Args:
            script: Text script for the podcast
            language: "hi" for Hindi, "en" for English
            topic: Podcast topic/name
            output_format: "mp3" or "wav"
            speaker: Speaker name
        
        Returns:
            Podcast generation result (single script only)
        """
        logger.warning("generate_podcast_single_script() is for single-language only. Use generate_full_podcast() for bilingual podcasts.")
        
        if not script:
            return {
                "success": False,
                "error": "Script is required"
            }
        
        # Save script
        script_path = await save_script(script, f"{topic}_{language}")
        
        if not script_path:
            return {
                "success": False,
                "error": "Failed to save script"
            }
        
        # Generate audio
        audio_path = await generate_audio_from_script(
            script=script,
            sarvam_api_key=self.sarvam_api_key,
            tts_url=self.tts_url,
            language=language,
            output_format=output_format,
            speaker=speaker
        )
        
        if not audio_path:
            return {
                "success": False,
                "error": "Failed to generate audio"
            }
        
        return {
            "success": True,
            "script_path": script_path,
            "audio_path": audio_path,
            "format": output_format,
            "language": language,
            "script_length": len(script),
            "speaker": speaker,
            "timestamp": datetime.now().isoformat()
        }


# Global instance
podcast_service = PodcastService()